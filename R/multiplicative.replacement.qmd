---
title: "Bayesian Multiplicative replacement"
format: html
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
library(zCompositions)
library(readr)
library(dplyr)

#bacteriome <- read.table("~/data/MAG.cluster.profiles.mapped.tsv",sep = ",", header =TRUE,row.names = NULL, check.names = FALSE)
#bacteriome

virome <- read.table("~/data/virome_families_for_multi_repl.tsv",sep = "\t", header =TRUE, check.names = FALSE)
#virome
```

```{r}
taxonomy <- read.table("~/data/MAG.cluster.taxonomy.tsv",sep = "\t", header =TRUE,row.names = NULL, check.names = FALSE)
taxonomy
```

```{r}



#check if the compositions are closed to 1 
bacteriome_T <- as.data.frame(virome)
# Suppose your dataframe is called df
# base R
#colnames(bacteriome_T) <- bacteriome_T[1, ]   # take first row as column names
#bacteriome_T <- bacteriome_T[-1, ]            # remove the first row
               # Remove that first row
rownames(bacteriome_T) <- bacteriome_T[[1]]
#bacteriome_T <- bacteriome_T[,- 1]            # remove the first row

bacteriome_T[[1]] <- NULL


bacteriome_T
```

```{r}
bacteriome_T[] <- lapply(bacteriome_T, function(x) as.numeric(as.character(x)))

col_sums <- colSums(bacteriome_T, na.rm = TRUE)

# Print results
#for (sample in names(col_sums)) {
#  cat(sample, ": sum =", sprintf("%.6f", col_sums[[sample]]), "\n")
#}
```

```{r}
#this is for the bacteriome
# If all columns are numeric
x <- as.matrix(bacteriome_T)

# If some columns are non-numeric, use this instead:
# x <- as.matrix(dplyr::select(bacteriome_T, where(is.numeric)))

zero_count <- sum(x == 0, na.rm = TRUE)
n_vals     <- sum(!is.na(x))              # total non-missing entries
pct_zero   <- (zero_count / n_vals) * 100

c(zero_count = zero_count, pct_zero = pct_zero)


```

```{r}
#this is for the virome
#this is for the 
# If all columns are numeric
x <- as.matrix(bacteriome_T)

# If some columns are non-numeric, use this instead:
# x <- as.matrix(dplyr::select(bacteriome_T, where(is.numeric)))

zero_count <- sum(x == 0, na.rm = TRUE)
n_vals     <- sum(!is.na(x))              # total non-missing entries
pct_zero   <- (zero_count / n_vals) * 100

c(zero_count = zero_count, pct_zero = pct_zero)

```

Nice the compositions were already closed

```{r}
# checkpoint
bacteriome <- bacteriome_T
bacteriome
```

Filtering of the bacteria that are not present in at least 10% of the individuals

```{r}
num_cols <- sapply(bacteriome, is.numeric)
min_present <- ceiling(0.10 * sum(num_cols))  # 10% of numeric sample columns
present_counts <- rowSums(bacteriome[, num_cols] != 0 & !is.na(bacteriome[, num_cols]))
bacteriome_filtered <- bacteriome[present_counts >= min_present, ]
dim(bacteriome_filtered)
bacteriome <- bacteriome_filtered
bacteriome

```

```{r}
mean(as.matrix(bacteriome) == 0, na.rm = TRUE) * 100

```

`method="CZM"` uses multiplicative simple replacement ([`multRepl`](http://localhost:8787/help/library/zCompositions/help/multRepl)) on the matrix of estimated probabilities. The upper limit and the fraction used are specified by, respectively, the arguments `threshold` and `frac`. Suggested values are `threshold=0.5` (so the upper limit for a multinomial probability turns out to be 0.5/*n*), and `frac=0.65` (so the imputed proportion is 65% of the upper limit).

The virome dataset contained three viruses(rows) that were all 0s. I have to drop this the two following blocks do just that (spot the viral species with all 0s and drop them from the dataset)

```{r}
X <- data.matrix(bacteriome)      # converts non-numerics to NA if needed
mode(X) <- "numeric"

# 1) Columns (samples)
cols_all_na    <- colSums(is.na(X)) == nrow(X)
cols_all_zero  <- !cols_all_na & colSums(replace(X, is.na(X), 0)) == 0

cat("== COLUMN CHECKS (samples) ==\n")
cat("All-NA columns (n=", sum(cols_all_na), "):\n", sep="")
if (any(cols_all_na)) print(colnames(X)[cols_all_na]) else cat("None\n")
cat("All-zero (or NA->0) columns (n=", sum(cols_all_zero), "):\n", sep="")
if (any(cols_all_zero)) print(colnames(X)[cols_all_zero]) else cat("None\n")

# 2) Rows (taxa)
rows_all_na    <- rowSums(is.na(X)) == ncol(X)
rows_all_zero  <- !rows_all_na & rowSums(replace(X, is.na(X), 0)) == 0

cat("\n== ROW CHECKS (taxa) ==\n")
cat("All-NA rows (n=", sum(rows_all_na), "):\n", sep="")
if (any(rows_all_na)) print(rownames(X)[rows_all_na]) else cat("None\n")
cat("All-zero (or NA->0) rows (n=", sum(rows_all_zero), "):\n", sep="")
if (any(rows_all_zero)) print(rownames(X)[rows_all_zero]) else cat("None\n")


```

```{r}
# Drop all-NA and all-zero rows (taxa)
rows_to_drop <- rows_all_na | rows_all_zero
cat("Dropping", sum(rows_to_drop), "rows (taxa) with all NA or all zero values.\n")

X_clean <- X[!rows_to_drop, , drop = FALSE]

# Optional: also drop problematic columns if needed
cols_to_drop <- cols_all_na | cols_all_zero
cat("Dropping", sum(cols_to_drop), "columns (samples) with all NA or all zero values.\n")

X_clean <- X_clean[, !cols_to_drop, drop = FALSE]

# Check dimensions after filtering
dim(X_clean)


```

```{r}
bacteriome <-X_clean 
X <- as.matrix(bacteriome)
if (any(X < 0, na.rm = TRUE)) stop("Input contains negative values.")
cs <- colSums(X, na.rm = TRUE)


#apply closure to 1
X <- sweep(X, 2, ifelse(cs == 0, NA, cs), "/")

# 2) zCompositions expects samples in ROWS -> transpose
X_t <- t(X)

X_t <-as.data.frame(X_t)

```

```{r}
X_t
```

This function implements methods for imputing zeros in compositional count data sets based on a Bayesian-multiplicative replacemen

```{r}

# 3) Multiplicative replacement with CZM (δ = 0.65 × min positive when DL unknown)
#    label=0 tells the function which entries are zeros

X_rep_t <- cmultRepl(
  X_t,
  label = 0,
  method = "CZM",
  output = "prop",
  z.warning = 1,      # effectively no warning threshold
  z.delete  = FALSE,  # do NOT delete high-zero columns
  suppress.print = TRUE
)



```

```{r}

# 4) Transpose back to taxa x samples and re-close columns (guard against numeric drift)
X_rep <- t(X_rep_t)
X_rep <- sweep(X_rep, 2, colSums(X_rep), "/")

# Result:
bacteriome_numeric_pc <- X_rep
```

```{r}
X_rep
```

```{r}
# 4) VERIFY closure
col_sums <- colSums(bacteriome_numeric_pc)
print(summary(col_sums))
cat("Min col sum:", min(col_sums), "\n")
cat("Max col sum:", max(col_sums), "\n")

tol <- 1e-12
offenders <- which(abs(col_sums - 1) > tol)
if (length(offenders) > 0) {
  cat("Columns not closed within tolerance:", paste(colnames(bacteriome_numeric_pc)[offenders], collapse = ", "), "\n")
} else {
  cat("All columns sum to 1 within tolerance (", tol, ").\n", sep = "")
}
```

```{r}
bacteriome_numeric_pc <- write.table(
  bacteriome_numeric_pc,
  file = "~/data/virome.multi.repl.tsv",
  sep = "\t",
  quote = FALSE,
  col.names = NA
)
```

```{r}
bacteriome_numeric_pc <- write.table(
  bacteriome_numeric_pc,
  file = "~/data/MAG.profiles.multirepl.tsv",
  sep = "\t",
  quote = FALSE,
  col.names = NA
)
```

### CLR tranformation

```{r}

#gm_per_sample <- exp(colMeans(log(microbes_numeric_pc)))
gm_per_sample <- exp(colMeans(log(bacteriome_numeric_pc)))

# CLR transform: log( value / column geometric mean )
#microbes_clr <- log(sweep(microbes_numeric_pc, 2, gm_per_sample, "/"))
bacteriome_clr <- log(sweep(bacteriome_numeric_pc, 2, gm_per_sample, "/"))

head(bacteriome_clr)

```

```{r}
# Sum CLR-transformed values per sample (column)
clr_sums <- colSums(bacteriome_clr)

# Print results
for (sample in names(clr_sums)) {
  cat(sample, ": sum =", sprintf("%.6f", clr_sums[[sample]]), "\n")
}

```

```{r}
# Write CLR-transformed table to TSV
write.table(
  bacteriome_clr,
  file = "~/data/MAG.profiles.processed.tsv",
  sep = "\t",
  quote = FALSE,
  col.names = NA
)

```

```{r}
write.table(
  bacteriome_clr,
  file = "~/data/virome.processed.tsv",
  sep = "\t",
  quote = FALSE,
  col.names = NA
)
```

ILR transformation for sPLS

CLR doesn t contain subsample cohesiveness

```{r}
df <- read.delim("~/data/virome.multi.repl.tsv", sep = "\t", header = TRUE)
write.csv(df, "~/data/virome.multi.repl.mimenet.csv", row.names = FALSE)

```
